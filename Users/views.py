from django.shortcuts import render, HttpResponse,redirect
from django.contrib import messages
from .forms import UserRegistrationForm
from .models import UserRegistrationModel, UserSearchUrlModel, CSRFResponse
import json
import subprocess
import pandas as pd
from .UserMachineLearningAlgorithm import MLConcepts
from django.conf import settings
import os
# Create your views here.
def UserHome(request):
        return render(request, 'Users/UserHome.html', {})

def UserPreProcessForm(request):
        return render(request, 'Users/UserPreProcessForm.html', {})

def UserCSRFProcessByBolt(request):
        if request.method == "POST":
                urlname = request.POST.get("urlname")
                depth = request.POST.get("depth")
                UserSearchUrlModel.objects.create(urlname=urlname, depthfecth=depth)
                bolt_file = os.path.join(settings.MEDIA_ROOT, 'Bolt-master', 'bolt.py')
                command =' '.join(['python',bolt_file,'-u',urlname,'-l', depth] )
                print("path " + command)
                subprocess.call(command)
                json_file_path = os.path.join(settings.MEDIA_ROOT, 'hashes.json')
                with open(json_file_path) as f:
                        data = json.load(f)
                mydict = {}
                for i in data:
                        keys = i.keys()
                        for x in keys:
                                regex = i['regex']
                                matches = i['matches']
                                CSRFResponse.objects.create(regex=regex, matches=matches, urlname=urlname)

                data = CSRFResponse.objects.filter(urlname=urlname)
                return render(request, 'Users/CSRFProcess.html', {"data": data})
        else:
                return render(request, 'Users/CSRFProcess.html')

def UserMitchProcess(request):
        json_file_path = os.path.join(settings.MEDIA_ROOT, 'dataset.json')
        with open(json_file_path) as f:
                data = json.load(f)
        mydict = {}
        for i in data:
                keys = i.keys()
                data = i['data']
                website = i['website']
                i = 0
                for x in data:
                        i =i+ 1
                        mydict.update({i: x})
    
        return render(request, 'Users/MitchProcessone.html', {"data": mydict})


def UserMachineLearning(request):
        csv_file_path = os.path.join(settings.MEDIA_ROOT, 'features_matrix.csv')

        try:
                df = pd.read_csv(csv_file_path, sep=',', delimiter=None, header='infer', names=None, index_col=None, usecols=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal='.', lineterminator=None, quotechar='"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None,   delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None)
                obj = MLConcepts()
                post_dict = obj.startPOSTProcess(df)
                get_dict = obj.startGETProcess(df)
                option_dict = obj.startOPTIONProcess(df)
        
                return render(request, "users/UserMachineLearning.html", {'post_dict': post_dict, 'get_dict': get_dict, 'option_dict': option_dict})
        except FileNotFoundError:
                return render(request, 'Users/UserMachineLearning.html', {'post_dict': {}, 'get_dict': {}, 'option_dict': {}})

